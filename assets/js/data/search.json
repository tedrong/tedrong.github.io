[ { "title": "Length of Last Word", "url": "/posts/length-of-last-word/", "categories": "LeetCode, Easy", "tags": "leetcode", "date": "2021-07-24 00:00:00 +0800", "snippet": "Given a string s consisting of some words separated by some number of spaces, return the length of the last word in the string.A word is a maximal substring consisting of non-space characters only.Example 1Input: s = &quot;Hello World&quot;Output: 5Explanation: The last word is &quot;World&quot; with length 5.Example 2Input: s = &quot; fly me to the moon &quot;Output: 4Explanation: The last word is &quot;moon&quot; with length 4.Example 3Input: s = &quot;luffy is still joyboy&quot;Output: 6Explanation: The last word is &quot;joyboy&quot; with length 6.Constraints 1 &amp;lt;= s.length &amp;lt;= 104 s consists of only English letters and spaces ‘ ‘. There will be at least one word in s.Solutionfunc lengthOfLastWord(s string) int { words := []byte(s) length := 0 if strings.Contains(s, &quot; &quot;) { for i := len(words) - 1; i &amp;gt;= 0; i-- { // fmt.Println(words[i]) if i == len(words)-1 &amp;amp;&amp;amp; words[i] == 32 { words = words[:len(words)-1] } else if words[i] != 32 { length++ } else { break } } } else { length = len(s) } return length}" }, { "title": "Maximum Subarray", "url": "/posts/maximum-subarray/", "categories": "LeetCode, Easy", "tags": "leetcode", "date": "2021-07-23 00:00:00 +0800", "snippet": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.A subarray is a contiguous part of an array.Example 1Input: nums = [-2,1,-3,4,-1,2,1,-5,4]Output: 6Explanation: [4,-1,2,1] has the largest sum = 6.Example 2Input: nums = [1]Output: 1Example 3Input: nums = [5,4,-1,7,8]Output: 23Constraints 1 &amp;lt;= nums.length &amp;lt;= 105 -104 &amp;lt;= nums[i] &amp;lt;= 104Solutionfunc maxSubArray(nums []int) int { var value int max := int(math.Pow(-2, 31) + 1) for idx, element := range nums { if idx == 0 { value = element } else if len(nums) &amp;gt; 0 { if value &amp;lt;= 0 { value = element } else { value += element } } if value &amp;gt; max { max = value } } return max}" }, { "title": "Search Insert Position", "url": "/posts/search-insert-position/", "categories": "LeetCode, Easy", "tags": "leetcode", "date": "2021-07-22 00:00:00 +0800", "snippet": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.You must write an algorithm with O(log n) runtime complexity.Example 1Input: nums = [1,3,5,6], target = 5Output: 2Example 2Input: nums = [1,3,5,6], target = 2Output: 1Example 3Input: nums = [1,3,5,6], target = 7Output: 4Example 4Input: nums = [1,3,5,6], target = 0Output: 0Example 5Input: nums = [1], target = 0Output: 0Constraints 1 &amp;lt;= nums.length &amp;lt;= 104 -104 &amp;lt;= nums[i] &amp;lt;= 104 nums contains distinct values sorted in ascending order. -104 &amp;lt;= target &amp;lt;= 104Solutionfunc searchInsert(nums []int, target int) int { for idx, element := range nums { if element &amp;gt;= target { if idx == 0 { return 0 } return idx } } return len(nums)}" }, { "title": "Implement strStr()", "url": "/posts/implement-strStr()/", "categories": "LeetCode, Easy", "tags": "leetcode", "date": "2021-07-21 00:00:00 +0800", "snippet": "Implement strStr().Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.ClarificationWhat should we return when needle is an empty string? This is a great question to ask during an interview.For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf().Example 1Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;Output: 2Example 2Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;Output: -1Example 3Input: haystack = &quot;&quot;, needle = &quot;&quot;Output: 0Constraints 0 &amp;lt;= haystack.length, needle.length &amp;lt;= 5 * 104 haystack and needle consist of only lower-case English characters.Solutionfunc strStr(haystack string, needle string) int { return strings.Index(haystack, needle)}" }, { "title": "Remove Element", "url": "/posts/remove-element/", "categories": "LeetCode, Easy", "tags": "leetcode", "date": "2021-07-20 00:00:00 +0800", "snippet": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.Return k after placing the final result in the first k slots of nums.Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.Custom Judge:The judge will test your solution with the following code:int[] nums = [...]; // Input arrayint val = ...; // Value to removeint[] expectedNums = [...]; // The expected answer with correct length. // It is sorted with no values equaling val.int k = removeElement(nums, val); // Calls your implementationassert k == expectedNums.length;sort(nums, 0, k); // Sort the first k elements of numsfor (int i = 0; i &amp;lt; actualLength; i++) { assert nums[i] == expectedNums[i];}If all assertions pass, then your solution will be accepted.Example 1Input: nums = [3,2,2,3], val = 3Output: 2, nums = [2,2,_,_]Explanation: Your function should return k = 2, with the first two elements of nums being 2.It does not matter what you leave beyond the returned k (hence they are underscores).Example 2Input: nums = [0,1,2,2,3,0,4,2], val = 2Output: 5, nums = [0,1,4,0,3,_,_,_]Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.Note that the five elements can be returned in any order.It does not matter what you leave beyond the returned k (hence they are underscores).Constraints 0 &amp;lt;= nums.length &amp;lt;= 100 0 &amp;lt;= nums[i] &amp;lt;= 50 0 &amp;lt;= val &amp;lt;= 100Solutionfunc removeElement(nums []int, val int) int { var temp []int if len(nums) == 0 { return 0 } for _, element := range nums { if element != val { temp = append(temp, element) } } for idx, element := range temp { nums[idx] = element } return len(temp)}" }, { "title": "Remove Duplicates from Sorted Array", "url": "/posts/remove-duplicates-from-sorted-array/", "categories": "LeetCode, Easy", "tags": "leetcode", "date": "2021-07-19 00:00:00 +0800", "snippet": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.Return k after placing the final result in the first k slots of nums.Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.Custom Judge:The judge will test your solution with the following code:int[] nums = [...]; // Input arrayint[] expectedNums = [...]; // The expected answer with correct lengthint k = removeDuplicates(nums); // Calls your implementationassert k == expectedNums.length;for (int i = 0; i &amp;lt; k; i++) { assert nums[i] == expectedNums[i];}If all assertions pass, then your solution will be accepted.Example 1Input: nums = [1,1,2]Output: 2, nums = [1,2,_]Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.It does not matter what you leave beyond the returned k (hence they are underscores).Example 2Input: nums = [0,0,1,1,1,2,2,3,3,4]Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.It does not matter what you leave beyond the returned k (hence they are underscores).Constraints 0 &amp;lt;= nums.length &amp;lt;= 3 * 104 -100 &amp;lt;= nums[i] &amp;lt;= 100 nums is sorted in non-decreasing order.Solutionfunc removeDuplicates(nums []int) int { tag := 999 count := 0 var ans []int for _, element := range nums { if element != tag { tag = element count++ ans = append(ans, element) } } for idx, element := range ans { nums[idx] = element } return count}" }, { "title": "Merge Two Sorted Lists", "url": "/posts/merge-two-sorted-lists/", "categories": "LeetCode, Easy", "tags": "leetcode", "date": "2021-07-18 00:00:00 +0800", "snippet": "Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.Example 1Input: l1 = [1,2,4], l2 = [1,3,4]Output: [1,1,2,3,4,4]Example 2Input: l1 = [], l2 = []Output: []Example 3Input: l1 = [], l2 = [0]Output: [0]Constraints The number of nodes in both lists is in the range [0, 50]. -100 &amp;lt;= Node.val &amp;lt;= 100 Both l1 and l2 are sorted in non-decreasing order.Solution/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil { return l2 } if l2 == nil { return l1 } if l1.Val &amp;lt; l2.Val { l1.Next = mergeTwoLists(l1.Next, l2) return l1 } else { l2.Next = mergeTwoLists(l1, l2.Next) return l2 }}" }, { "title": "Valid Parentheses", "url": "/posts/valid-parentheses/", "categories": "LeetCode, Easy", "tags": "leetcode", "date": "2021-07-17 00:00:00 +0800", "snippet": "Given a string s containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[’ and ‘]’, determine if the input string is valid.An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.Example 1Input: s = &quot;()&quot;Output: trueExample 2Input: s = &quot;()[]{}&quot;Output: trueExample 3Input: s = &quot;([)]&quot;Output: falseConstraints 1 &amp;lt;= s.length &amp;lt;= 104 s consists of parentheses only ‘()[]{}’.Solutionfunc isValid(s string) bool { m := make(map[string]string) m[&quot;)&quot;] = &quot;(&quot; m[&quot;]&quot;] = &quot;[&quot; m[&quot;}&quot;] = &quot;{&quot; stack := []string{} for _, symbol := range strings.Split(s, &quot;&quot;) { if strings.Contains(&quot;([{&quot;, symbol) { stack = append(stack, symbol) } else if len(stack) &amp;gt; 0{ // fmt.Printf(&quot;stack : %s, map: %s\\n&quot;, stack[len(stack)-1], m[symbol]) // fmt.Println(stack[len(stack)-1] == m[symbol]) if stack[len(stack)-1] == m[symbol] { stack = stack[:len(stack)-1] } else { return false } } else { return false } } if len(stack) == 0 { return true } return false}" }, { "title": "Longest Common Prefix", "url": "/posts/longest-common-prefix/", "categories": "LeetCode, Easy", "tags": "leetcode", "date": "2021-07-16 00:00:00 +0800", "snippet": "Write a function to find the longest common prefix string amongst an array of strings.If there is no common prefix, return an empty string “”.Example 1Input: strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot;Example 2Input: strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]Output: &quot;&quot;Explanation: There is no common prefix among the input strings.Constraints 1 &amp;lt;= strs.length &amp;lt;= 200 0 &amp;lt;= strs[i].length &amp;lt;= 200 strs[i] consists of only lower-case English letters.Solutionfunc longestCommonPrefix(strs []string) string { // Get shortest string length := 200 prefix := &quot;&quot; for _, str := range strs { if len(str) &amp;lt; length { length = len(str) prefix = str } } for i := 0; i &amp;lt; length; i++ { for _, str := range strs { if !strings.HasPrefix(str, prefix) { prefix = prefix[:len(prefix)-1] break } } } return prefix}" }, { "title": "Roman to Integer", "url": "/posts/roman-to-integer/", "categories": "LeetCode, Easy", "tags": "leetcode", "date": "2021-07-15 00:00:00 +0800", "snippet": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.Symbol ValueI 1V 5X 10L 50C 100D 500M 1000For example, 2 is written as II in Roman numeral, just two one’s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900.Given a roman numeral, convert it to an integer.Example 1Input: s = &quot;III&quot;Output: 3Example 2Input: s = &quot;IV&quot;Output: 4Example 3Input: s = &quot;IX&quot;Output: 9Example 4Input: s = &quot;LVIII&quot;Output: 58Explanation: L = 50, V= 5, III = 3.Example 5Input: s = &quot;MCMXCIV&quot;Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.Constraints 1 &amp;lt;= s.length &amp;lt;= 15 s contains only the characters (‘I’, ‘V’, ‘X’, ‘L’, ‘C’, ‘D’, ‘M’). It is guaranteed that s is a valid roman numeral in the range [1, 3999].Solutionfunc romanToInt(s string) int { ans := 0 var m map[string]int m = make(map[string]int) m[&quot;I&quot;] = 1 m[&quot;V&quot;] = 5 m[&quot;X&quot;] = 10 m[&quot;L&quot;] = 50 m[&quot;C&quot;] = 100 m[&quot;D&quot;] = 500 m[&quot;M&quot;] = 1000 m[&quot;IV&quot;] = 4 m[&quot;IX&quot;] = 9 m[&quot;XL&quot;] = 40 m[&quot;XC&quot;] = 90 m[&quot;CD&quot;] = 400 m[&quot;CM&quot;] = 900 digits := strings.Split(s, &quot;&quot;) for idx, digit := range digits { base := 0 if idx &amp;gt; 0 &amp;amp;&amp;amp; m[digit] &amp;gt; m[digits[idx-1]] { base = m[digit] - 2*m[digits[idx-1]] } else { base = m[digit] } ans += base } return ans}" }, { "title": "Palindrome Number", "url": "/posts/palindrome-number/", "categories": "LeetCode, Easy", "tags": "leetcode", "date": "2021-07-14 00:00:00 +0800", "snippet": "Given an integer x, return true if x is palindrome integer.An integer is a palindrome when it reads the same backward as forward. For example, 121 is palindrome while 123 is not.Example 1Input: x = 121Output: trueExample 2Input: x = -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.Example 3Input: x = 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome.Constraints -231 &amp;lt;= x &amp;lt;= 231 - 1Solutionfunc isPalindrome(x int) bool { ans := true digits := strings.Split(strconv.Itoa(x), &quot;&quot;) for idx, digit := range digits { tail := len(digits) - 1 - idx if idx == tail || idx &amp;gt; tail { break } if digit != digits[tail] { ans = false break } } return ans}" }, { "title": "Two Sum", "url": "/posts/two-sum/", "categories": "LeetCode, Easy", "tags": "leetcode", "date": "2021-07-13 00:00:00 +0800", "snippet": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.You may assume that each input would have exactly one solution, and you may not use the same element twice.You can return the answer in any order.Example 1Input: nums = [2,7,11,15], target = 9Output: [0,1]Output: Because nums[0] + nums[1] == 9, we return [0, 1].Example 2Input: nums = [3,2,4], target = 6Output: [1,2]Example 3Input: nums = [3,3], target = 6Output: [0,1]Constraints 2 &amp;lt;= nums.length &amp;lt;= 104 -109 &amp;lt;= nums[i] &amp;lt;= 109 -109 &amp;lt;= target &amp;lt;= 109 Only one valid answer exists.Solutionfunc twoSum(nums []int, target int) []int { m := make(map[int]int) for idx, element := range nums { flag := target - element if _, ok := m[flag]; ok { return []int{m[flag], idx} } else { m[element] = idx } } return nil}" }, { "title": "Install and run database", "url": "/posts/install-and-run-database/", "categories": "Programing, Note", "tags": "database, docker", "date": "2021-07-12 22:21:00 +0800", "snippet": "Getting ImagesPostgres$ docker pull postgresRedis$ docker pull redisCreate systemd serviceMake a executable script file$ sudo vim /usr/local/bin/docker-dev-database.sh#!/bin/bashdocker run --rm --name postgreSQL -e POSTGRES_PASSWORD=docker -d -p 5432:5432 -v $HOME/docker/volumes/postgres:/var/lib/postgresql/data postgresdocker run --rm -itd --name Redis -p 6379:6379 redisCreate new serviceMake a new service description at /etc/systemd/system/docker-dev-database.service[Unit]After=network.service[Service]ExecStart=/usr/local/bin/docker-dev-database.sh[Install]WantedBy=default.target Reload the service files to include the new service. sudo systemctl daemon-reload Start your service. sudo systemctl start docker-dev-database.service To check the status of your service. sudo systemctl status docker-dev-database.service To enable your service on every reboot. sudo systemctl enable docker-dev-database.service To disable your service on every reboot. sudo systemctl disable docker-dev-database.service " } ]
